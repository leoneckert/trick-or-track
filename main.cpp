//
//  main.cpp
//  requests_not_made
//
//  Created by Leon Eckert on 06/03/2016.
//  Copyright Â© 2016 Leon Eckert. All rights reserved.
//


#include <iostream>
#include <tins/tins.h>
#include <vector>
#include <string>
#include <sstream>
#include <map>


using namespace Tins;
using namespace std; 


map<string, vector<vector <string>>> currentClouds; // Map1
const int maxPktInterval = 2; //interval that defines which packets are considered part of the same cloud
const int minCloudSize = 100;
vector<vector<vector<string>>> cloudsToAnalyse;
map<string, map<string, int>> analysisOutput;

void printOutCurrentCloud(){
    for (auto& x : currentClouds){
        cout << "MAC is: " << x.first << endl;
        cout << "\telements in cloud: " << x.second.size() << endl;
        for (auto& y : x.second){
            cout << "\t\thost: " << y[0] <<  "\ttimestamp: " << y[1] << endl;
        }
    }
}

void printOutAnalysisClouds(){
    for (auto& x : analysisOutput){
        cout << "-------------------------------------------------------------------"  << endl;
        cout << "____________" << endl;
        cout << "| Main Host: " << x.first << endl;
        cout << "------------"  << endl;
        
        std::vector<std::pair<int, string>> sortVector;
        for (auto& y : x.second){
            sortVector.emplace_back(y.second, y.first);
        }
        stable_sort(std::begin(sortVector), std::end(sortVector));
        cout << setw(35) << "[hosts]" << "\t" << "[number of requests]" << endl;
        cout << setw(35) << "--------------------" << "\t" << "--------------------" << endl;
        for (int i = 0; i < sortVector.size(); i++){
            int idx = (int) sortVector.size() - 1 - i;
            cout << setw(35) << sortVector[idx].second << "\t" << sortVector[idx].first << endl;
//            cout << "\thost: " << sortVector[idx].second << setw(25) << "\t#requests: " << sortVector[idx].first << endl;
        }
    }
    analysisOutput = {}; //(optional)
}

string turnHostIntoShortFrom(const string& _hostname){
    string hostname = _hostname;
    string shortHost = hostname;
    int lengthOrigName = (int) hostname.length();
    int dotCount = 0;
    int cutSpot1;
    int cutSpot2;
    for(int i = 0; i < lengthOrigName; i++){
        string currentLetter = hostname.substr(lengthOrigName - i - 1, 1);
        if (currentLetter ==  "." && i != 0){
            
            dotCount = dotCount + 1;
            if (dotCount == 1) {
                cutSpot2 = lengthOrigName - i - 1;
                shortHost = shortHost.substr(0, cutSpot2);
            }
            if (dotCount == 2) {
                cutSpot1 = lengthOrigName - i;
                shortHost = shortHost.substr(cutSpot1);
                break;
            }
        }
    }
    return shortHost;
}


////////////////////////////////////////////////
////////////////////////////////////////////////
//////////////[ Analyse Clouds ]////////////////
////////////////////////////////////////////////
////////////////////////////////////////////////
void analyseClouds(){
    for (vector<vector<string>>& cloud :cloudsToAnalyse){
        map<string, int> TempMap;
        for (vector<string>& requestVec :cloud){
            string shortHost = turnHostIntoShortFrom(requestVec[0]);
//            string shortHost = requestVec[0];
            if (TempMap.find(shortHost) == TempMap.end()) {
                //not found:
                TempMap[shortHost] = 1;
            }else{
                //found:
                TempMap[shortHost] += 1;
            }
        }
        int highest = 0;
        string mostFrequentShortHost = "";
        for(auto& x : TempMap){
            if (x.second > highest && x.first != "[unknown]") {
                highest = x.second;
                mostFrequentShortHost = x.first;
            }
        }
        if (analysisOutput.find(mostFrequentShortHost) == analysisOutput.end()) {
            //not found:
            analysisOutput[mostFrequentShortHost] = TempMap;
        }else{
            //found:
            for(auto& x : TempMap){
                if (analysisOutput[mostFrequentShortHost].find(x.first) == analysisOutput[mostFrequentShortHost].end()) {
                    //not found:
                    analysisOutput[mostFrequentShortHost][x.first] = x.second;
                }else{
                    //found:
                    analysisOutput[mostFrequentShortHost][x.first] += x.second;
                }
            }
        }
    }
    
    vector<vector<vector<string>>> emptyVector;
    cloudsToAnalyse = emptyVector;
    
    printOutAnalysisClouds();
}



////////////////////////////////////////////////
////////////////////////////////////////////////
///////////////[ Process Line ]/////////////////
////////////////////////////////////////////////
////////////////////////////////////////////////
void processLine(const vector<string>& vectorToPrint, const vector<string>& requestedHeaders){
//this function is desinged to process a input vector of the pattern: host, get, src, dst, timestamp
    if (vectorToPrint.size() == requestedHeaders.size() + 3) {
        string MAC = vectorToPrint[2];
        string host = vectorToPrint[0];
        if(vectorToPrint[0].substr(0,6) == "Host: "){
            host = vectorToPrint[0].substr(6);
        }
        string timestamp = vectorToPrint[4];
        
        vector<string> requestVector;
        requestVector.push_back(host);
        requestVector.push_back(timestamp);
        
        if (currentClouds.find(MAC) == currentClouds.end()) {
            // not found:
            vector<vector<string>> emptyVector;
            currentClouds[MAC] = emptyVector;
            currentClouds[MAC].push_back(requestVector);
            
        }else{
            //found:
            if (currentClouds[MAC].size() > 0) {
                //curretntly elements in cloud:
                int idxLastElement = (int) currentClouds[MAC].size() - 1;
                long timestampLastRequest = stol (currentClouds[MAC][idxLastElement][1]);
                long currentTimestamp = stol (timestamp);
                
                if (currentTimestamp - timestampLastRequest < maxPktInterval) {
                    // belongs to same cloud
                    currentClouds[MAC].push_back(requestVector);
                }else{
                    // old cloud is finished
                    if (currentClouds[MAC].size() < minCloudSize) {
                        //do nothing, cloud is irrelevant and will be deleted below
                    }else{
                        cloudsToAnalyse.push_back(currentClouds[MAC]);
                    }
                    vector<vector<string>> emptyVector;
                    currentClouds[MAC] = emptyVector;
                    currentClouds[MAC].push_back(requestVector);
                }
            
            }else{
                //curretntly NO elements in cloud:
                currentClouds[MAC].push_back(requestVector);
            }
        }
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////[  GET HEADER FUNCTIONS  ]///////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////
////////////////////////////////////////////////
//////////////[ Get Timestamp ]/////////////////
////////////////////////////////////////////////
////////////////////////////////////////////////
long get_timestamp(Packet pkt){
    long timestamp = pkt.timestamp().seconds();
    return timestamp;
}
////////////////////////////////////////////////
////////////////////////////////////////////////
//////////////////[ Get Src ]///////////////////
////////////////////////////////////////////////
////////////////////////////////////////////////
string get_src_from_pdu(const PDU &pdu){
    const Dot11Data &dot11Data = pdu.rfind_pdu<Dot11Data>();
    string src = dot11Data.src_addr().to_string();
    
    return src;
}
////////////////////////////////////////////////
////////////////////////////////////////////////
//////////////////[ Get Dst ]///////////////////
////////////////////////////////////////////////
////////////////////////////////////////////////
string get_dst_from_pdu(const PDU &pdu){
    const Dot11Data &dot11Data = pdu.rfind_pdu<Dot11Data>();
    string dst = dot11Data.dst_addr().to_string();
    
    return dst;
}
////////////////////////////////////////////////
////////////////////////////////////////////////
////////////////[ Get Header ]//////////////////
////////////////////////////////////////////////
////////////////////////////////////////////////
string get_header_from_raw(string header, const RawPDU& rawpdu){
    
    string payL = "";
    string content = "";
    const RawPDU::payload_type& payload = rawpdu.payload();
    for (const auto& bit : payload) {
        payL += (char) bit;
    }
    
    int pos_header = (int) payL.find(header);
    
    if(pos_header != -1){
        content = payL.substr(pos_header);
        int endHeader = (int) content.find("\n");
        content = content.substr(0, endHeader - 1);
    }
//    else if(pos_header == -1){
//        content = "[unknown]";
//    }
    
    return content;
}
////////////////////////////////////////////////
////////////////////////////////////////////////
////////////////[ Get Raw Pdu ]/////////////////
////////////////////////////////////////////////
////////////////////////////////////////////////
const RawPDU& get_raw_pdu(const PDU &pdu){
    const RawPDU &raw = pdu.rfind_pdu<RawPDU>();
    return raw;
}
////////////////////////////////////////////////
////////////////////////////////////////////////
///////////[ Check if Data11 PDU ]//////////////
////////////////////////////////////////////////
////////////////////////////////////////////////
bool hasData11packet(const PDU& pdu){
    try {
        //probably a more elegant solution
        const Dot11Data &dot11Data = pdu.rfind_pdu<Dot11Data>();
        return true;
    }catch (...) {return false;}
}
////////////////////////////////////////////////
////////////////////////////////////////////////
//////[ Get Requested Headers from pkt ]////////
////////////////////////////////////////////////
////////////////////////////////////////////////
vector<string> get_headers_from_pkts(vector<string> requestedHeaders, const Packet& pkt){
    vector<string> output;
    // here is where we do stuff with packets:
    const PDU& pdu = *pkt.pdu();
    
    // check if we find a dot11data packet:
    if (hasData11packet(pdu)) {
        
        // if yes, get the rawPDU and do something with it
        try{
            const RawPDU& raw = get_raw_pdu(pdu);
            
            try{
                
                vector<string> requestedHeadersReturn;
                for(auto h : requestedHeaders){
                    requestedHeadersReturn.push_back(get_header_from_raw(h, raw));
                }
                
                for(auto s : requestedHeadersReturn){
                    // 3 here is quite arbitrary
                    if (s.length() > 3) {
                        output.push_back(s);
                    }
                }
                string src = get_src_from_pdu(pdu);
                string dst = get_dst_from_pdu(pdu);
                string ts;
                stringstream strstream;
                strstream << get_timestamp(pkt);
                strstream >> ts;

                
                output.push_back(src);
                output.push_back(dst);
                output.push_back(ts);
                
            }catch(...){}
            
        }catch(...){}
    }
    return output;
}
////////////////////////////////////////////////
////////////////////////////////////////////////
///////////[ Print out the Output ]/////////////
////////////////////////////////////////////////
////////////////////////////////////////////////
void printOutputVector(const vector<string>& vectorToPrint, const vector<string>& requestedHeaders){
    if (vectorToPrint.size() == requestedHeaders.size() + 3) {
        bool first = true;
        
        for (string s : vectorToPrint){
            if (!first) {
                cout << " , ";
            }
            first = false;
            cout << s;
        }
        cout << endl;
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


void startSniffing(std::string _interface, bool monitorMode){
    
    // configure the sniffer:
    std::string interface = _interface;
    SnifferConfiguration config;
    config.set_promisc_mode(true);
    config.set_rfmon(monitorMode);
    Sniffer sniffer(interface, config);
    
    // now sniff:
    try {
        
        while(Packet pkt = sniffer.next_packet()) {
            
            vector<string> headersWanted = {"Host: ","GET"};
            vector<string> headerVector = get_headers_from_pkts(headersWanted, pkt);

            analyseClouds();
            processLine(headerVector, headersWanted);

            
        }
    }catch(...){}
    
}

int main(){
    startSniffing("en0", true);
}